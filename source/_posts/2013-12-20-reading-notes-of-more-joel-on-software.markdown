---
layout: post
title: "Reading notes of More Joel on Software"
date: 2013-12-20 23:09
comments: true
categories: 
---

日复一日写程序，扪心自问，从junior到senior，积累的是什么。[Joel Spolsky](http://www.joelonsoftware.com/)就是一个略带奇葩乐于分享能满足我好奇心的人，[More Joel on Software](http://book.douban.com/subject/4163938/)记录了他博客上关于软件开发的随笔。一些启发性的内容：

> 我的第一次BillG审查

> - BillG真的会以技术视角审视决定，做批判性思考。软件公司要让懂编程的人来管理

> 寻找优秀的程序员

> - 优秀的程序员大多不在人才市场。他们优秀以至于大多数时候不需要找工作，只要在自己喜欢的地方待着就可以

> 寻找优秀的程序员之实战指南

> - 假定你要找的是优秀程序员
> - 站在求职者的位置设身处地的想，对方会抓住任何细节来形成对你公司的印象，所以要十分注重对方参观办公室的体验，如果有必要，把怪人藏起来
> - 让一流新员工挑选他们想参与的项目，使用非必要的热门新技术（让他们开心一些），认同公司，给他们的工作带来意义

> 三种管理方法————军事化管理

> - 军队需要个体牺牲以达到整体最优结果，因此要养成个人服从命令的天性；软件公司中因为程序员可以轻易离开，不能用这种方法

> 三种管理方法————经济利益驱动法

> - 假定每个人的行为动机都是金钱，给予物质奖励或惩罚，创造动机；比如用bug数或各种考核指标和奖励惩罚挂钩
> - 问题：让内部激励（自发的，强有力的）变成了外部激励（被动的，弱的）
> - 更大问题，人有追求局部利益最大化的倾向，而程序员又是高智商群体，会想各种办法让报酬最大化，鼓励程序员和制度博弈
> - 其实这根本不是管理，更像是管理的退位，或者说是一种设计精巧的推卸责任的方法，不愿承担责任找到把事情做得更好的方法。它是一个信号，表明管理层根本不知道如何引导人们做出更好的工作，所以强迫每个人在制度框架下自己想办法把事情做好。当你创造一种制度的时候，不能放弃自己的职责，不能通过发钱的方式来训练他们。

> 三种管理方法————认同法

> - 使人们认同你的目标。比如聘请实习生到纽约的一个目的是让他们喜欢纽约继而留在本公司。
> - 提供必要的信息让员工可以自己做决策。

<!-- more -->

> 给计算机系学生的建议

> - 条目很多，这是比较特别的两点：
>   - 毕业前练好写作：最有权威和影响力的程序员往往是表达能力强的程序员，能清晰、自如、有说服力的传达观点。即使如Linus，如果不是超强的表达能力，Linux也无法取得如此成功。
>   - 学好微观经济学：一个理解基本商业规则的程序员会更有价值。我看到过太多提出疯狂想法的程序员，也许在代码上可行，但在资本世界中毫无意义。

> 火星人的耳机 和 为什么Microsoft Office的文件格式如此复杂

> - 这两篇的内容有相似之处，讲解为什么IE、Office套件会成为事实标准而又积重难返。文章写得深入浅出，以至于我觉得很难概括描述，还是推荐读原文理解。大致的感受如下
> - 一些背景和假设
>   - 软件开发中分为两派，理论派和务实派。理论派类似于现实中的左派，希望激进的推行标准前进，以及完备的测试；务实派更愿意妥协，兼容性更重要
>   - 开发中测试永远无法达到完全自动和完备的程度，因为如果可以达到，那测试代码的信息熵和软件代码的信息熵将等量。
>   - 对很多技术标准来说，最初的版本难免有历史局限性，外界的实现难免会出现多个有细微差别的版本；标准更新时，就会受限于兼容性
> - 在浏览器, Windows和Office的问题上类似，解析器A被认为能够解析满足标准B的实现C，微软承担了制定最初版本A1和B1的角色，虽然不完美，但因此产生了大量兼容它们的C1, C2 .. Cn。为了升级，微软推出了向前兼容的新版本A2, B2，继而出现了更多的实现C21, C22, .. C2n。如此B的束缚作用逐渐淡化，最终变成了A1, .. An 对 C11, ... Cnx的多对多兼容。所以每次升级都要在理论和务实间妥协，至少你根本没法放弃现有用户，而完全追求"更好的标准"，这意味着用户会放弃你的标准。
> - Joel没有给出怎么做才会更好。我觉得这些问题确实很难避免，造成的原因有
>   - 问题足够复杂，网页、OS、Office格式
>   - 野蛮式的快速发展，对商业利益的追求，最初的日子里，对标准的优化并不是最重要，添加feature，满足需求，兼容老用户才是
>   - 事实上对实现和标准制定的垄断加重了问题

> 飙高音

> - 程序员的生产效率差别巨大，即使在“优秀”的程序员间，生产效率差别依然巨大
> - 平庸程序员很难成为优秀程序员
> - 软件行业赢家通吃

> 揉一揉，搓一搓

> - 大多数情况下，重构代码比重写代码更划算
> - 老代码并不像看上去那么一无是处，其实包含了大量以往的劳动成果、错误修正和经验，重构比重写节约大量劳动

> 五个为什么

> - SLA的最大问题，缺乏制定标准必须的统计资料，无法知道多长的运行时间才是正常的。
> - 日本丰田创始人的思想：当某个地方出错的时候，就问为什么，一遍遍的追问，直到找到根本原因为止
>   - 机房连接中断了，为什么？网线接口好像不工作了
>   - 为什么？网速/双工模式不匹配造成
>   - 为什么？交换机的网速开关设在了自动调节，而没有被手动设置在固定档
>   - 为什么？许多年前，我们就直到有可能发生此故障，但始终没有写出一份书面技术文档，用于知道交换机在生产环境中配置
>   - 为什么？我们总是很狭隘的看待技术文档，觉得只有在找不到管理员的情况下才需要看。没有意识到要把它作为技术操作的标准和确认清单
> - 为服务稳定性设定一个静态值为目标意义不大，而是需要一个不断改进工作质量的流程。如搭建一个fail log，记录每次中断以及完整的时候分析，找到根本原因。


可以看出Joel对于程序员极为重视，以至于让我觉得有些过度了，而较少谈到程序员的弱点和限制，虽然这样会让程序员更爱读这些文章。就我的感受，程序员确实是十分聪明的群体，热爱专注于解决问题，但局限性同样明显，专注的问题之外的领域往往被他们忽略。Joel以上的一些观点其实并不多高深，尤其关于管理方法，也许对于管理专业而言是基本常识，但在草莽的软件行业，正是普遍被忽略的。
